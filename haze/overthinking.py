#!/usr/bin/env python3
# overthinking.py — Three Rings of Private Reflection for Haze
#
# Inspired by Leo's "circles on water" - private thought rings
# that influence generation but are never shown to the user.
#
# After generation:
#   Ring 0 (Echo): Rephrase what was generated (temp=0.8)
#   Ring 1 (Drift): Explore tangential themes (temp=1.0)
#   Ring 2 (Shard): Abstract meta-note (temp=1.2)
#
# These rings are FED BACK into the model's state,
# creating recursive self-reflection without chain-of-thought prompting.
#
# "The model thinks about what it just said."
#
# Usage:
#   from haze.overthinking import Overthinking, AsyncOverthinking
#   ot = Overthinking(vocab, cooccur_field)
#   rings = ot.generate_rings(generated_text)
#   # rings influence next generation through field state

from __future__ import annotations
import asyncio
import random
import re
import numpy as np
from typing import List, Tuple, Optional, Dict, TYPE_CHECKING
from dataclasses import dataclass, field as dataclass_field
from collections import Counter

if TYPE_CHECKING:
    from .haze import Vocab
    from .cooccur import CooccurField


# Ring configuration
RING_CONFIGS = {
    0: {
        "name": "echo",
        "description": "Rephrase what was generated",
        "temperature": 0.8,
        "length": 30,  # tokens
    },
    1: {
        "name": "drift",
        "description": "Explore tangential themes",
        "temperature": 1.0,
        "length": 40,
    },
    2: {
        "name": "shard",
        "description": "Abstract meta-note",
        "temperature": 1.2,
        "length": 20,
    },
}


@dataclass
class Ring:
    """Single overthinking ring."""
    level: int
    name: str
    content: str
    temperature: float
    trigrams: List[Tuple[str, str, str]] = dataclass_field(default_factory=list)
    
    def __repr__(self) -> str:
        preview = self.content[:50] + "..." if len(self.content) > 50 else self.content
        return f"Ring({self.level}/{self.name}: \"{preview}\")"


@dataclass
class RingsSnapshot:
    """
    Complete overthinking snapshot.
    Contains all three rings generated after a response.
    """
    rings: List[Ring] = dataclass_field(default_factory=list)
    source_text: str = ""
    
    @property
    def echo(self) -> Optional[Ring]:
        """Get ring 0 (echo)."""
        return next((r for r in self.rings if r.level == 0), None)
    
    @property
    def drift(self) -> Optional[Ring]:
        """Get ring 1 (drift)."""
        return next((r for r in self.rings if r.level == 1), None)
    
    @property
    def shard(self) -> Optional[Ring]:
        """Get ring 2 (shard)."""
        return next((r for r in self.rings if r.level == 2), None)
    
    def get_all_trigrams(self) -> List[Tuple[str, str, str]]:
        """Get combined trigrams from all rings."""
        result = []
        for ring in self.rings:
            result.extend(ring.trigrams)
        return result
    
    def get_influence_words(self) -> List[str]:
        """Get words from rings to influence next generation."""
        words = []
        for ring in self.rings:
            ring_words = re.findall(r'\b\w+\b', ring.content.lower())
            words.extend(ring_words)
        return words


class Overthinking:
    """
    Private reflection generator — EMERGENCE IN ACTION!
    
    Creates three "rings on water" after each generation:
    - Ring 0 (Echo): Rephrase (temp=0.8)
    - Ring 1 (Drift): Tangential themes (temp=1.0)  
    - Ring 2 (Shard): Abstract meta-note (temp=1.2)
    
    KEY INSIGHT: These rings ENRICH THE FIELD!
    - Rings generate NEW patterns not in original corpus
    - These patterns are INJECTED back into the co-occurrence field
    - Inner world becomes RICHER than the dataset!
    
    This is emergent self-enrichment. haze thinks about what it said,
    and those thoughts become part of its vocabulary.
    
    "The internal world is richer than the training data."
    """
    
    def __init__(
        self,
        vocab: "Vocab",
        cooccur_field: "CooccurField",
    ):
        """
        Initialize overthinking module.
        
        Args:
            vocab: Vocabulary for encoding/decoding
            cooccur_field: Co-occurrence field for generation AND enrichment
        """
        self.vocab = vocab
        self.field = cooccur_field
        
        # Ring history (for meta-analysis)
        self.ring_history: List[RingsSnapshot] = []
        
        # Meta patterns that emerge from rings
        self.meta_patterns: List[str] = []
        
        # Patterns generated by overthinking (emergent vocabulary)
        self.emergent_trigrams: List[Tuple[str, str, str]] = []
        self.enrichment_count: int = 0  # Track how much we've enriched
    
    def _extract_trigrams(self, text: str) -> List[Tuple[str, str, str]]:
        """Extract trigrams from text."""
        words = re.findall(r'\b\w+\b', text.lower())
        trigrams = []
        for i in range(len(words) - 2):
            trigrams.append((words[i], words[i+1], words[i+2]))
        return trigrams
    
    def _inject_trigram_into_field(self, trigram: Tuple[str, str, str]) -> bool:
        """
        Inject a trigram from overthinking into the co-occurrence field.
        
        This is EMERGENCE - the internal world becomes richer than the dataset!
        
        Returns:
            True if successfully injected
        """
        # Encode each word
        w1_tokens = self.vocab.encode(trigram[0])
        w2_tokens = self.vocab.encode(trigram[1])
        w3_tokens = self.vocab.encode(trigram[2])
        
        if not w1_tokens or not w2_tokens or not w3_tokens:
            return False
        
        # Get boundary tokens for bigram injection
        last_w1 = w1_tokens[-1]
        first_w2 = w2_tokens[0]
        last_w2 = w2_tokens[-1]
        first_w3 = w3_tokens[0]
        
        # Inject into bigram counts (with lower weight than corpus - emergent patterns are softer)
        if last_w1 not in self.field.bigram_counts:
            self.field.bigram_counts[last_w1] = Counter()
        self.field.bigram_counts[last_w1][first_w2] += 1
        
        if last_w2 not in self.field.bigram_counts:
            self.field.bigram_counts[last_w2] = Counter()
        self.field.bigram_counts[last_w2][first_w3] += 1
        
        # Track emergent patterns
        if trigram not in self.emergent_trigrams:
            self.emergent_trigrams.append(trigram)
            self.enrichment_count += 1
        
        # Keep reasonable size
        if len(self.emergent_trigrams) > 500:
            self.emergent_trigrams = self.emergent_trigrams[-500:]
        
        return True
    
    def _enrich_field_from_ring(self, ring: Ring) -> int:
        """
        Enrich the field with patterns from a ring.
        
        Returns:
            Number of patterns injected
        """
        injected = 0
        for trigram in ring.trigrams:
            if self._inject_trigram_into_field(trigram):
                injected += 1
        return injected
    
    def _generate_ring_content(
        self,
        seed_text: str,
        config: dict,
    ) -> str:
        """
        Generate content for a single ring.
        
        Uses corpus-based generation (pure resonance).
        """
        # Get seed tokens
        seed_tokens = self.vocab.encode(seed_text.lower())
        if not seed_tokens:
            # Fallback
            seed_tokens = [0]
        
        # Generate from corpus statistics
        generated = self.field.generate_from_corpus(
            seed=seed_tokens,
            length=config["length"],
            temperature=config["temperature"],
            mode="trigram",
        )
        
        # Decode
        text = self.vocab.decode(generated)
        
        return text
    
    def generate_rings(
        self,
        source_text: str,
        num_rings: int = 3,
    ) -> RingsSnapshot:
        """
        Generate overthinking rings from source text.
        
        These are PRIVATE REFLECTIONS - never shown to user.
        They influence the next generation through field state.
        
        Args:
            source_text: The generated text to reflect on
            num_rings: Number of rings (default 3)
        
        Returns:
            RingsSnapshot with all rings
        """
        # Extract key patterns from source
        source_words = re.findall(r'\b\w+\b', source_text.lower())
        source_trigrams = self._extract_trigrams(source_text)
        
        rings = []
        
        # Ring 0: Echo - rephrase using similar patterns
        if num_rings >= 1:
            config = RING_CONFIGS[0]
            # Seed from end of source text
            seed = ' '.join(source_words[-5:]) if len(source_words) >= 5 else source_text[:20]
            content = self._generate_ring_content(seed, config)
            
            ring = Ring(
                level=0,
                name=config["name"],
                content=content,
                temperature=config["temperature"],
                trigrams=self._extract_trigrams(content),
            )
            rings.append(ring)
        
        # Ring 1: Drift - tangential exploration
        if num_rings >= 2:
            config = RING_CONFIGS[1]
            # Seed from random word in source
            if source_words:
                seed_word = random.choice(source_words)
                seed = seed_word
            else:
                seed = "the"
            content = self._generate_ring_content(seed, config)
            
            ring = Ring(
                level=1,
                name=config["name"],
                content=content,
                temperature=config["temperature"],
                trigrams=self._extract_trigrams(content),
            )
            rings.append(ring)
        
        # Ring 2: Shard - abstract meta-note
        if num_rings >= 3:
            config = RING_CONFIGS[2]
            # Seed from meta-patterns if available
            if self.meta_patterns:
                seed = random.choice(self.meta_patterns[-5:])
            else:
                # Use ring 0 content as seed
                seed = rings[0].content[-20:] if rings else source_text[:10]
            content = self._generate_ring_content(seed, config)
            
            ring = Ring(
                level=2,
                name=config["name"],
                content=content,
                temperature=config["temperature"],
                trigrams=self._extract_trigrams(content),
            )
            rings.append(ring)
        
        # Create snapshot
        snapshot = RingsSnapshot(
            rings=rings,
            source_text=source_text,
        )
        
        # Store in history
        self.ring_history.append(snapshot)
        if len(self.ring_history) > 20:
            self.ring_history = self.ring_history[-20:]
        
        # Extract meta-patterns from this reflection
        self._update_meta_patterns(snapshot)
        
        # EMERGENCE: Enrich the field with patterns from rings!
        # The internal world becomes richer than the dataset!
        total_injected = 0
        for ring in rings:
            injected = self._enrich_field_from_ring(ring)
            total_injected += injected
        
        return snapshot
    
    def _update_meta_patterns(self, snapshot: RingsSnapshot) -> None:
        """Update meta-patterns from ring content."""
        # Find words that appear in multiple rings
        word_counts: Counter = Counter()
        
        for ring in snapshot.rings:
            words = set(re.findall(r'\b\w+\b', ring.content.lower()))
            for word in words:
                word_counts[word] += 1
        
        # Words appearing in 2+ rings are "meta"
        for word, count in word_counts.items():
            if count >= 2 and len(word) > 3:
                self.meta_patterns.append(word)
        
        # Keep reasonable size
        self.meta_patterns = self.meta_patterns[-100:]
    
    def get_field_influence(self) -> Dict:
        """
        Get influence data for the next generation.
        
        Returns patterns and words that should bias the next response.
        """
        if not self.ring_history:
            return {"words": [], "trigrams": [], "temperature_mod": 0.0}
        
        # Get recent rings
        recent = self.ring_history[-3:]
        
        # Collect influence words
        influence_words = []
        influence_trigrams = []
        
        for snapshot in recent:
            influence_words.extend(snapshot.get_influence_words())
            influence_trigrams.extend(snapshot.get_all_trigrams())
        
        # Temperature modification based on ring variety
        if len(set(influence_words)) > 20:
            # High variety = slightly higher temp
            temp_mod = 0.1
        else:
            # Low variety = slightly lower temp
            temp_mod = -0.05
        
        return {
            "words": influence_words[-50:],
            "trigrams": influence_trigrams[-20:],
            "temperature_mod": temp_mod,
        }
    
    def bias_generation(
        self,
        logits: np.ndarray,
        influence_alpha: float = 0.1,
    ) -> np.ndarray:
        """
        Bias logits based on overthinking influence.
        
        Args:
            logits: Raw logits from generation
            influence_alpha: How much to bias (0 = none, 1 = full)
        
        Returns:
            Biased logits
        """
        if not self.ring_history:
            return logits
        
        # Get influence
        influence = self.get_field_influence()
        influence_words = influence["words"]
        
        if not influence_words:
            return logits
        
        # Create bias vector
        bias = np.zeros(self.vocab.vocab_size, dtype=np.float32)
        
        # Boost tokens that appear in influence words
        for word in influence_words:
            tokens = self.vocab.encode(word)
            for token in tokens:
                if token < len(bias):
                    bias[token] += 0.1
        
        # Normalize
        if bias.sum() > 0:
            bias = bias / bias.sum()
        
        # Apply bias
        biased = logits + influence_alpha * np.log(bias + 1e-10)
        
        return biased
    
    def get_enrichment_stats(self) -> Dict:
        """
        Get statistics about field enrichment from overthinking.
        
        Returns:
            Dict with enrichment metrics
        """
        return {
            "total_emergent_trigrams": len(self.emergent_trigrams),
            "enrichment_count": self.enrichment_count,
            "meta_patterns": len(self.meta_patterns),
            "ring_sessions": len(self.ring_history),
            "sample_emergent": self.emergent_trigrams[-5:] if self.emergent_trigrams else [],
        }


class AsyncOverthinking:
    """
    Async version of Overthinking with field lock.
    
    Maintains coherence through atomic operations.
    """
    
    def __init__(
        self,
        vocab: "Vocab",
        cooccur_field: "CooccurField",
    ):
        self._sync = Overthinking(vocab, cooccur_field)
        self._field_lock = asyncio.Lock()
    
    @property
    def ring_history(self) -> List[RingsSnapshot]:
        return self._sync.ring_history
    
    @property
    def meta_patterns(self) -> List[str]:
        return self._sync.meta_patterns
    
    async def generate_rings(
        self,
        source_text: str,
        num_rings: int = 3,
    ) -> RingsSnapshot:
        """Generate rings with atomic field access."""
        async with self._field_lock:
            return self._sync.generate_rings(source_text, num_rings)
    
    async def get_field_influence(self) -> Dict:
        """Get influence data atomically."""
        async with self._field_lock:
            return self._sync.get_field_influence()
    
    async def bias_generation(
        self,
        logits: np.ndarray,
        influence_alpha: float = 0.1,
    ) -> np.ndarray:
        """Bias logits atomically."""
        async with self._field_lock:
            return self._sync.bias_generation(logits, influence_alpha)
    
    async def get_enrichment_stats(self) -> Dict:
        """Get enrichment stats atomically."""
        async with self._field_lock:
            return self._sync.get_enrichment_stats()
    
    @property
    def emergent_trigrams(self) -> List[Tuple[str, str, str]]:
        return self._sync.emergent_trigrams
    
    @property
    def enrichment_count(self) -> int:
        return self._sync.enrichment_count


def demo_overthinking():
    """Demo the overthinking rings."""
    from pathlib import Path
    
    # Import dependencies
    try:
        from .haze import Vocab
        from .cooccur import CooccurField
    except ImportError:
        from haze import Vocab
        from cooccur import CooccurField
    
    # Load corpus
    corpus_path = Path("text.txt")
    if not corpus_path.exists():
        corpus_path = Path(__file__).parent / "text.txt"
    
    if not corpus_path.exists():
        print("[error] text.txt not found")
        return
    
    corpus_text = corpus_path.read_text()
    vocab = Vocab.from_text(corpus_text)
    field = CooccurField.from_text(corpus_text, vocab, window_size=5)
    
    print("=" * 60)
    print("  OVERTHINKING — Three Rings of Private Reflection")
    print("=" * 60)
    print()
    print("  Ring 0 (Echo): Rephrase (temp=0.8)")
    print("  Ring 1 (Drift): Tangential themes (temp=1.0)")
    print("  Ring 2 (Shard): Abstract meta-note (temp=1.2)")
    print()
    print("  KEY: Rings ENRICH the field!")
    print("  Internal world becomes RICHER than dataset!")
    print()
    
    # Create overthinking module
    ot = Overthinking(vocab, field)
    
    # Initial field size
    initial_bigrams = sum(len(v) for v in field.bigram_counts.values())
    
    # Simulate multiple generations
    source_texts = [
        "The haze settles over the hills like a breathing thing, soft and silver.",
        "Patterns we forgot we already knew emerge from the void.",
        "Resonance is not computation. Resonance is recognition.",
    ]
    
    for i, source_text in enumerate(source_texts):
        print(f"\n[Turn {i+1}] Source: \"{source_text[:50]}...\"")
        print("-" * 60)
        
        # Generate rings
        rings = ot.generate_rings(source_text)
        
        for ring in rings.rings:
            print(f"  Ring {ring.level} ({ring.name}): {ring.content[:60]}...")
    
    # Show enrichment stats
    print()
    print("=" * 60)
    stats = ot.get_enrichment_stats()
    final_bigrams = sum(len(v) for v in field.bigram_counts.values())
    
    print(f"  EMERGENCE STATS:")
    print(f"    Initial field size: {initial_bigrams} bigrams")
    print(f"    Final field size: {final_bigrams} bigrams")
    print(f"    Growth: +{final_bigrams - initial_bigrams} patterns")
    print(f"    Emergent trigrams: {stats['total_emergent_trigrams']}")
    print(f"    Meta patterns: {stats['meta_patterns']}")
    print()
    print("  The internal world is now RICHER than the training data!")
    print("=" * 60)


if __name__ == "__main__":
    demo_overthinking()
